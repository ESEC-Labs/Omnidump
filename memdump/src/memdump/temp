import re

def get_address_and_permissions(section):
    """
    Extracts the address and permissions from a single section dictionary.

    Args:
        section (dict): A dictionary representing a single section.

    Returns:
        tuple: A tuple containing the address (str) and permissions (str).
    """
    address = section.get('address', 'N/A')
    permissions = section.get('permissions', 'N/A')
    path = section.get('file_path', 'N/A')
    return (address, permissions, path)





def process_lines(line):
    '''
    Uses pattern matching get the detailed information from a line in the maps file

    Args:

    Returns: 
    '''
    match = re.match(r"(\w{0,16}+-\w{0,16})\s+(.{4})\s+(\w{8})\s+(\d{2}+:\d{2})\s+(\d[0-9]{0,8})\s*(.+)", line)
    if not match: 
            print(f"No match for: {line.strip()}")
            return None 

    address, permissions, offsets, maj_min_id, inode, file_path= match.groups()

    return {
            "address": address,
            "permissions": permissions,
            "offsets": offsets,
            "maj_min_id": maj_min_id,
            "inode": inode,
            "file_path": file_path
            }

                
                

def group_regions(file_path):
    '''
    This dictionary contains the sections of data that match a certain condition.
    For example if the section has the stack label it's metadata (addresses, etc.) 
    would be stored in the stack list.
    '''
    '''
    The function also acts as a helper function for the dump_bytes_mem function below.
    It returns a completed dictionary of a the sections in a /proc/id/maps
    '''
    section_categories = {
        "executable": [],
        "shared_libs": [],
        "heap": [], 
        "stack": [],
        "vvar": [],
        "vsyscall": [],
        "vdso": [],
        "none": []
    }


    f_path_target_char = "/"
    h_target_char = "[heap]"
    s_target_char = "[stack]"
    vvar_target_char = "[vvar]"
    vsyscall_target_char = "[vsyscall]"
    vdso_target_char = "[vdso]"

    with open(file_path, "r") as file: 
        file_content = file.readlines()

        for line in file_content:
            result = process_lines(line)

            if not result: 
                continue
            
            current_path = result.get("file_path","")

            # Check if a match was successfully made
            if h_target_char in current_path:
                section_categories["heap"].append(result)
            elif s_target_char in current_path:
                section_categories["stack"].append(result)
            elif vvar_target_char in current_path:
                section_categories["vvar"].append(result)
            elif vsyscall_target_char in current_path:
                section_categories["vsyscall"].append(result)
            elif vdso_target_char in current_path:
                section_categories["vdso"].append(result)

            # Libraries vs other file-backed mappings
            elif current_path and f_path_target_char in current_path:
                if current_path.endswith(".so"):
                    section_categories["shared_libs"].append(result)
                elif "bin/" in current_path or current_path.endswith("exe") or "firefox" in current_path:  
                    section_categories["executable"].append(result)

            # Default: unclassified
            else:
                section_categories["none"].append(result)

            return section_categories

def format_output_bytes(mem_path, input_dict, exec_sec, slib_sec, all_sec, he_sec, st_sec, vvar_sec, vsys_sec, vdso_sec, none_sec):

    
    sections_to_dump = []

    # If the user chose to show all sections
    if all_sec is True:
        sections_to_dump = list(input_dict.keys())
    else:
        # Otherwise, build the list based on specific flags
        if exec_sec:
            sections_to_dump.append("executable")
        if slib_sec:
            print(f"Format output function shared libs sections var: {slib_sec}")
            sections_to_dump.append("shared_libs")
        if he_sec:
            sections_to_dump.append("heap")
        if st_sec:
            sections_to_dump.append("stack")
        if vvar_sec:
            sections_to_dump.append("vvar")
        if vsys_sec:
            sections_to_dump.append("vsyscall")
        if vdso_sec:
            sections_to_dump.append("vdso")
        if none_sec:
            sections_to_dump.append("none")

    print(sections_to_dump)


    with open(mem_path, "rb") as mem: 
        for category_name in sections_to_dump:
            # Access the list of sections for the current category
            sections_list = input_dict.get(category_name, [])
            print("Section list: ", sections_list)

            if not sections_list:
                print(f"\n--- {category_name.upper()} SECTIONS (No entries) ---\n")
                continue
                
            print(f"\n--- {category_name.upper()} SECTIONS ---\n")
            
            for line_num, section in enumerate(sections_list, 1):
                # Call the helper function to get the data
                address, permissions, path = get_address_and_permissions(section)
                start, end = [int(x, 16) for x in address.split("-")]

                if "r" in permissions: 
                    size = end - start
                    if size <= 0:
                        continue
                    try:
                        mem.seek(start)
                        chunk = mem.read(size)
                        print(f"{line_num}: Chunk Size: {len(chunk)} bytes from {path} | Address Range: ({hex(start)}-{hex(end)})")
                    except OSError as e:
                        print(f"Could not read region {hex(start)}-{hex(end)}: {e}")

def dump_bytes_mem(mem_path, input_dict, exec_sec, slib_sec, all_sec, he_sec, st_sec, vvar_sec, vsys_sec, vdso_sec, none_sec):
    '''
    Uses pattern matching get the detailed information from a line in the maps file
    from the group_regions file.

    Uses the format_output_bytes function to format the output
    '''

    format_output_bytes(mem_path, input_dict, exec_sec, slib_sec, all_sec, he_sec, st_sec, vvar_sec, vsys_sec, vdso_sec, none_sec)

    

